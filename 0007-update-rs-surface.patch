From 8f9783368e3fbb1c5330bab20dff086f6437b302 Mon Sep 17 00:00:00 2001
From: andrew0229 <zhangzhao62@huawei.com>
Date: Wed, 15 Nov 2023 09:39:44 +0000
Subject: [PATCH 7/7] update rs surface

Signed-off-by: andrew0229 <zhangzhao62@huawei.com>
Change-Id: Ia728779c3d2b6fc2863dadf299ac6e7b0b4e8623
---
 .../ohos/backend/native_buffer_utils.cpp      | 48 +++++++-------
 .../ohos/backend/rs_surface_ohos_vulkan.cpp   | 63 +++++++++++--------
 .../ohos/backend/rs_surface_ohos_vulkan.h     |  9 ++-
 3 files changed, 71 insertions(+), 49 deletions(-)

diff --git a/rosen/modules/render_service_base/src/platform/ohos/backend/native_buffer_utils.cpp b/rosen/modules/render_service_base/src/platform/ohos/backend/native_buffer_utils.cpp
index e59eeda2b..ae89621fb 100755
--- a/rosen/modules/render_service_base/src/platform/ohos/backend/native_buffer_utils.cpp
+++ b/rosen/modules/render_service_base/src/platform/ohos/backend/native_buffer_utils.cpp
@@ -27,13 +27,16 @@ void DeleteVkImage(void* context)
 }
 
 bool GetNativeBufferFormatProperties(const RsVulkanContext& vkContext, VkDevice device, OH_NativeBuffer* nativeBuffer,
-                                     VkNativeBufferFormatPropertiesOHOS& nbFormatProps,
-                                     VkNativeBufferPropertiesOHOS& nbProps)
+                                     VkNativeBufferFormatPropertiesOHOS* nbFormatProps,
+                                     VkNativeBufferPropertiesOHOS* nbProps)
 {
-    nbFormatProps.sType = VK_STRUCTURE_TYPE_NATIVE_BUFFER_FORMAT_PROPERTIES_OHOS;
-    nbFormatProps.pNext = nullptr;
+    nbFormatProps->sType = VK_STRUCTURE_TYPE_NATIVE_BUFFER_FORMAT_PROPERTIES_OHOS;
+    nbFormatProps->pNext = nullptr;
 
-    VkResult err = vkContext.vkGetNativeBufferPropertiesOHOS(device, nativeBuffer, &nbFormatProps);
+    nbProps->sType = VK_STRUCTURE_TYPE_NATIVE_BUFFER_PROPERTIES_OHOS;
+    nbProps->pNext = nbFormatProps;
+
+    VkResult err = vkContext.vkGetNativeBufferPropertiesOHOS(device, nativeBuffer, nbProps);
     if (VK_SUCCESS != err) {
         ROSEN_LOGE("RSSurfaceOhosVulkan GetNativeBufferPropertiesOHOS Failed ! %d", err);
         return false;
@@ -41,8 +44,8 @@ bool GetNativeBufferFormatProperties(const RsVulkanContext& vkContext, VkDevice
     return true;
 }
 
-bool CreateVkImage(const RsVulkanContext& vkContext, VkImage& image,
-    const VkNativeBufferFormatPropertiesOHOS& nbFormatProps, int width, int height)
+bool CreateVkImage(const RsVulkanContext& vkContext, VkImage* image,
+    const VkNativeBufferFormatPropertiesOHOS* nbFormatProps, int width, int height)
 {
     VkExternalFormatOHOS externalFormat;
     externalFormat.sType = VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_OHOS;
@@ -55,7 +58,7 @@ bool CreateVkImage(const RsVulkanContext& vkContext, VkImage& image,
         VK_EXTERNAL_MEMORY_HANDLE_TYPE_OHOS_NATIVE_BUFFER_BIT_OHOS, // handleTypes
     };
     VkImageUsageFlags usageFlags = VK_IMAGE_USAGE_SAMPLED_BIT;
-    if (nbFormatProps.format != VK_FORMAT_UNDEFINED) {
+    if (nbFormatProps->format != VK_FORMAT_UNDEFINED) {
         usageFlags = usageFlags | VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT |
             VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
     }
@@ -69,7 +72,7 @@ bool CreateVkImage(const RsVulkanContext& vkContext, VkImage& image,
         &externalMemoryImageInfo,
         flags,
         VK_IMAGE_TYPE_2D,
-        nbFormatProps.format,
+        nbFormatProps->format,
         {width, height, 1},
         1,
         1,
@@ -82,14 +85,16 @@ bool CreateVkImage(const RsVulkanContext& vkContext, VkImage& image,
         VK_IMAGE_LAYOUT_UNDEFINED,
     };
 
-    VkResult err = vkContext.vkCreateImage(device, &imageCreateInfo, nullptr, &image);
+    VkResult err = vkContext.vkCreateImage(vkContext.GetDevice(), &imageCreateInfo, nullptr, image);
     if (err != VK_SUCCESS) {
         ROSEN_LOGE("RSSurfaceOhosVulkan: CreateImage failed");
         return false;
     }
+    return true;
 }
 
-bool AllocateDeviceMemory(const RsVulkanContext& vkContext, VkPhysicalDevice physicalDevice, VkImage& image)
+bool AllocateDeviceMemory(const RsVulkanContext& vkContext, VkDeviceMemory* memory, VkImage& image,
+    OH_NativeBuffer* nativeBuffer, VkNativeBufferPropertiesOHOS& nbProps)
 {
     VkPhysicalDeviceMemoryProperties2 physicalDeviceMemProps;
     physicalDeviceMemProps.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
@@ -97,6 +102,8 @@ bool AllocateDeviceMemory(const RsVulkanContext& vkContext, VkPhysicalDevice phy
 
     uint32_t foundTypeIndex = 0;
     uint32_t foundHeapIndex = 0;
+    VkDevice device = vkContext.GetDevice();
+    VkPhysicalDevice physicalDevice = vkContext.GetPhysicalDevice();
     vkContext.vkGetPhysicalDeviceMemoryProperties2(physicalDevice, &physicalDeviceMemProps);
     uint32_t memTypeCnt = physicalDeviceMemProps.memoryProperties.memoryTypeCount;
     bool found = false;
@@ -106,7 +113,7 @@ bool AllocateDeviceMemory(const RsVulkanContext& vkContext, VkPhysicalDevice phy
             uint32_t supportedFlags = pdmp.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
             if (supportedFlags == VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) {
                 foundTypeIndex = i;
-                foundHeapIndex = pdmp.memoryTypes[i].foundHeapIndex;
+                foundHeapIndex = pdmp.memoryTypes[i].heapIndex;
                 found = true;
                 break;
             }
@@ -133,7 +140,7 @@ bool AllocateDeviceMemory(const RsVulkanContext& vkContext, VkPhysicalDevice phy
         VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO, &dedicatedAllocInfo, nbProps.allocationSize, foundTypeIndex,
     };
 
-    VkResult err = vkContext.vkAllocateMemory(device, &allocInfo, nullptr, &memory);
+    VkResult err = vkContext.vkAllocateMemory(device, &allocInfo, nullptr, memory);
     if (err != VK_SUCCESS) {
         vkContext.vkDestroyImage(device, image, nullptr);
         ROSEN_LOGE("RSSurfaceOhosVulkan AllocateMemory Fail");
@@ -143,7 +150,7 @@ bool AllocateDeviceMemory(const RsVulkanContext& vkContext, VkPhysicalDevice phy
 }
 
 
-bool BindImageMemory(VkPhysicalDevice device, const RsVulkanContext& vkContext, VkImage& image, VkDeviceMemory memory)
+bool BindImageMemory(VkDevice device, const RsVulkanContext& vkContext, VkImage& image, VkDeviceMemory memory)
 {
     VkBindImageMemoryInfo bindImageInfo;
     bindImageInfo.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
@@ -153,7 +160,7 @@ bool BindImageMemory(VkPhysicalDevice device, const RsVulkanContext& vkContext,
     bindImageInfo.memoryOffset = 0;
 
     VkResult err = vkContext.vkBindImageMemory2(device, 1, &bindImageInfo);
-    if (VK_SUCCESS != err) {
+    if (err != VK_SUCCESS) {
         ROSEN_LOGE("RSSurfaceOhosVulkan BindImageMemory2 failed");
         vkContext.vkDestroyImage(device, image, nullptr);
         vkContext.vkFreeMemory(device, memory, nullptr);
@@ -173,7 +180,6 @@ bool MakeFromNativeWindowBuffer(sk_sp<GrDirectContext> skContext, NativeWindowBu
 
     auto& vkContext = RsVulkanContext::GetSingleton();
 
-    VkPhysicalDevice physicalDevice = vkContext.GetPhysicalDevice();
     VkDevice device = vkContext.GetDevice();
 
     VkNativeBufferFormatPropertiesOHOS nbFormatProps;
@@ -183,21 +189,21 @@ bool MakeFromNativeWindowBuffer(sk_sp<GrDirectContext> skContext, NativeWindowBu
     }
 
     VkImage image;
-    if (!CreateVkImage(vkContext, image, nbFormatProps, width, height)) {
+    if (!CreateVkImage(vkContext, &image, &nbFormatProps, width, height)) {
         return false;
     }
 
     VkDeviceMemory memory;
-    if (!AllocateDeviceMemory(physicalDevice ,&memory)) {
+    if (!AllocateDeviceMemory(vkContext, &memory, image, nativeBuffer, nbProps)) {
         return false;
     }
 
     if (!BindImageMemory(device, vkContext, image, memory)) {
-        retrun false;
+        return false;
     }
 
     GrVkImageInfo image_info;
-    image_info.fImage_ = image;
+    image_info.fImage = image;
     image_info.fImageTiling = VK_IMAGE_TILING_OPTIMAL;
     image_info.fImageLayout = VK_IMAGE_LAYOUT_UNDEFINED;
     image_info.fFormat = nbFormatProps.format;
@@ -211,7 +217,7 @@ bool MakeFromNativeWindowBuffer(sk_sp<GrDirectContext> skContext, NativeWindowBu
 
     nativeSurface.skSurface = SkSurface::MakeFromBackendRenderTarget(
         skContext.get(), backend_render_target, kTopLeft_GrSurfaceOrigin, kRGBA_8888_SkColorType,
-        SkColorSpace::MakeSRGB(), &props, delete_vk_image, new VulkanCleanupHelper(RsVulkanContext::GetSingleton(),
+        SkColorSpace::MakeSRGB(), &props, DeleteVkImage, new VulkanCleanupHelper(RsVulkanContext::GetSingleton(),
         image, memory));
 
     nativeSurface.image = image;
diff --git a/rosen/modules/render_service_base/src/platform/ohos/backend/rs_surface_ohos_vulkan.cpp b/rosen/modules/render_service_base/src/platform/ohos/backend/rs_surface_ohos_vulkan.cpp
index c87949d2f..3fb462675 100644
--- a/rosen/modules/render_service_base/src/platform/ohos/backend/rs_surface_ohos_vulkan.cpp
+++ b/rosen/modules/render_service_base/src/platform/ohos/backend/rs_surface_ohos_vulkan.cpp
@@ -15,7 +15,6 @@
 
 #include "rs_surface_ohos_vulkan.h"
 
-
 #ifndef ENABLE_NATIVEBUFFER
 #include <vulkan_proc_table.h>
 #include <vulkan_native_surface_ohos.h>
@@ -54,25 +53,27 @@ RSSurfaceOhosVulkan::~RSSurfaceOhosVulkan()
 }
 
 #ifdef ENABLE_NATIVEBUFFER
-void CreateVkSemaphore(VkSemaphore semaphore, const RsVulkanContext& vkContext, NativeSurfaceInfo& nativeSurface)
+void RSSurfaceOhosVulkan::CreateVkSemaphore(
+    VkSemaphore* semaphore, const RsVulkanContext& vkContext, NativeBufferUtils::NativeSurfaceInfo& nativeSurface)
 {
     VkSemaphoreCreateInfo semaphoreInfo;
     semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
     semaphoreInfo.pNext = nullptr;
     semaphoreInfo.flags = 0;
-    vkContext.vkCreateSemaphore(vkContext.GetDevice(), &semaphoreInfo, nullptr, &semaphore);
+    vkContext.vkCreateSemaphore(vkContext.GetDevice(), &semaphoreInfo, nullptr, semaphore);
 
     VkImportSemaphoreFdInfoKHR importSemaphoreFdInfo;
     importSemaphoreFdInfo.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
     importSemaphoreFdInfo.pNext = nullptr;
-    importSemaphoreFdInfo.semaphore = semaphore;
+    importSemaphoreFdInfo.semaphore = *semaphore;
     importSemaphoreFdInfo.flags = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT;
     importSemaphoreFdInfo.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
     importSemaphoreFdInfo.fd = nativeSurface.fence->Dup();
     vkContext.vkImportSemaphoreFdKHR(vkContext.GetDevice(), &importSemaphoreFdInfo);
 }
 
-void RequestNativeWindowBuffer(NativeWindowBuffer* nativeWindowBuffer)
+int32_t RSSurfaceOhosVulkan::RequestNativeWindowBuffer(
+    NativeWindowBuffer** nativeWindowBuffer, int32_t width, int32_t height, int& fenceFd)
 {
     NativeWindowHandleOpt(mNativeWindow, SET_FORMAT, pixelFormat_);
 #ifdef RS_ENABLE_AFBC
@@ -90,21 +91,21 @@ void RequestNativeWindowBuffer(NativeWindowBuffer* nativeWindowBuffer)
     NativeWindowHandleOpt(mNativeWindow, SET_BUFFER_GEOMETRY, width, height);
     NativeWindowHandleOpt(mNativeWindow, GET_BUFFER_GEOMETRY, &mHeight, &mWidth);
     NativeWindowHandleOpt(mNativeWindow, SET_COLOR_GAMUT, colorSpace_);
-    
-    struct timespe curTime = {0, 0};
+
+    struct timespec curTime = {0, 0};
     clock_gettime(CLOCK_MONOTONIC, &curTime);
+    // 1000000000 is used for transfer second to nsec
     uint64_t duration = static_cast<uint64_t>(curTime.tv_sec) * 1000000000 + static_cast<uint64_t>(curTime.tv_nsec);
-    NativeWindowHandleOpt(mWindow, SET_UI_TIMESTAMP, duration);
+    NativeWindowHandleOpt(mNativeWindow, SET_UI_TIMESTAMP, duration);
 
-    int fenceFd = -1;
-    auto res = NativeWindowRequestBuffer(mNativeWindow, &nativeWindowBuffer, &fenceFd);
+    auto res = NativeWindowRequestBuffer(mNativeWindow, nativeWindowBuffer, &fenceFd);
     if (res != OHOS::GSERROR_OK) {
         ROSEN_LOGE("RSSurfaceOhosVulkan: OH_NativeWindow_NativeWindowRequestBuffer failed %{public}d", res);
-        NativeWindowCancelBuffer(mNativeWindow, nativeWindowBuffer);
+        NativeWindowCancelBuffer(mNativeWindow, *nativeWindowBuffer);
     }
+    return res;
 }
 
-
 std::unique_ptr<RSSurfaceFrame> RSSurfaceOhosVulkan::RequestFrame(int32_t width, int32_t height,
     uint64_t uiTimestamp, bool useAFBC)
 {
@@ -117,11 +118,15 @@ std::unique_ptr<RSSurfaceFrame> RSSurfaceOhosVulkan::RequestFrame(int32_t width,
         ROSEN_LOGE("RSSurfaceOhosVulkan: skia context is nullptr");
         return nullptr;
     }
+
     NativeWindowBuffer* nativeWindowBuffer = nullptr;
+    int fenceFd = -1;
+    if (RequestNativeWindowBuffer(&nativeWindowBuffer, width, height, fenceFd) != OHOS::GSERROR_OK) {
+        return nullptr;
+    }
 
-    RequestNativeWindowBuffer(nativeWindowBuffer);
     mSurfaceList.emplace_back(nativeWindowBuffer);
-    NativeSurfaceInfo& nativeSurface = mSurfaceMap[nativeWindowBuffer];
+    NativeBufferUtils::NativeSurfaceInfo& nativeSurface = mSurfaceMap[nativeWindowBuffer];
 
     if (nativeSurface.skSurface == nullptr) {
         nativeSurface.window = mNativeWindow;
@@ -216,16 +221,18 @@ std::unique_ptr<RSSurfaceFrame> RSSurfaceOhosVulkan::RequestFrame(int32_t width,
 
 void RSSurfaceOhosVulkan::SetUiTimeStamp(const std::unique_ptr<RSSurfaceFrame>& frame, uint64_t uiTimestamp)
 {
-    // if (mNativeWindow == nullptr) {
-    //     mNativeWindow = CreateNativeWindowFromSurface(&producer_);
-    //     ROSEN_LOGD("RSSurfaceOhosVulkan: create native window");
-    // }
-
-    // struct timespec curTime = {0, 0};
-    // clock_gettime(CLOCK_MONOTONIC, &curTime);
-    // // 1000000000 is used for transfer second to nsec
-    // uint64_t duration = static_cast<uint64_t>(curTime.tv_sec) * 1000000000 + static_cast<uint64_t>(curTime.tv_nsec);
-    // NativeWindowHandleOpt(mNativeWindow, SET_UI_TIMESTAMP, duration);
+#ifndef ENABLE_NATIVEBUFFER
+    if (mNativeWindow == nullptr) {
+        mNativeWindow = CreateNativeWindowFromSurface(&producer_);
+        ROSEN_LOGD("RSSurfaceOhosVulkan: create native window");
+    }
+
+    struct timespec curTime = {0, 0};
+    clock_gettime(CLOCK_MONOTONIC, &curTime);
+    // 1000000000 is used for transfer second to nsec
+    uint64_t duration = static_cast<uint64_t>(curTime.tv_sec) * 1000000000 + static_cast<uint64_t>(curTime.tv_nsec);
+    NativeWindowHandleOpt(mNativeWindow, SET_UI_TIMESTAMP, duration);
+#endif // ENABLE_NATIVEBUFFER
 }
 
 #ifdef ENABLE_NATIVEBUFFER
@@ -261,8 +268,12 @@ bool RSSurfaceOhosVulkan::FlushFrame(std::unique_ptr<RSSurfaceFrame>& frame, uin
 
     int fenceFd = -1;
 
+    auto queue = vkContext.GetQueue();
+    if (vkContext.GetHardWareGrContext().get() == mSkContext.get()) {
+        queue = vkContext.GetHardwareQueue();
+    }
     auto err = RsVulkanContext::interceptedVkQueueSignalReleaseImageOHOS(
-        vkContext.GetQueue(), 1, &semaphore, surface.image, &fenceFd);
+        queue, 1, &semaphore, surface.image, &fenceFd);
     if (err != VK_SUCCESS) {
         ROSEN_LOGE("RSSurfaceOhosVulkan QueueSignalReleaseImageOHOS failed %{public}d", err);
         return false;
@@ -275,9 +286,9 @@ bool RSSurfaceOhosVulkan::FlushFrame(std::unique_ptr<RSSurfaceFrame>& frame, uin
     }
     mSurfaceList.pop_front();
     vkContext.vkDestroySemaphore(vkContext.GetDevice(), semaphore, nullptr);
+    surface.fence.reset();
     surface.lastPresentedCount = mPresentCount;
     mPresentCount++;
-    surface.fence.reset();
     return true;
 }
 #else // ENABLE_NATIVEBUFFER
diff --git a/rosen/modules/render_service_base/src/platform/ohos/backend/rs_surface_ohos_vulkan.h b/rosen/modules/render_service_base/src/platform/ohos/backend/rs_surface_ohos_vulkan.h
index bdb344385..e916e9a38 100644
--- a/rosen/modules/render_service_base/src/platform/ohos/backend/rs_surface_ohos_vulkan.h
+++ b/rosen/modules/render_service_base/src/platform/ohos/backend/rs_surface_ohos_vulkan.h
@@ -17,7 +17,8 @@
 #define RS_SURFACE_OHOS_VULKAN_H
 
 // default enable native buffer
-
+#include <cstdint>
+#define ENABLE_NATIVEBUFFER
 
 #ifndef ENABLE_NATIVEBUFFER
 #include <vulkan_window.h>
@@ -28,6 +29,7 @@
 #include "vulkan/vulkan_core.h"
 #include "platform/ohos/backend/rs_vulkan_context.h"
 #include "sync_fence.h"
+#include "native_buffer_utils.h"
 #endif // ENABLE_NATIVEBUFFER
 
 #include <surface.h>
@@ -69,9 +71,12 @@ private:
     std::list<NativeWindowBuffer*> mSurfaceList;
     std::unordered_map<NativeWindowBuffer*, NativeBufferUtils::NativeSurfaceInfo> mSurfaceMap;
     sk_sp<GrDirectContext> mSkContext = nullptr;
+    int32_t RequestNativeWindowBuffer(NativeWindowBuffer** nativeWindowBuffer, int32_t width, int32_t height, int& fenceFd);
+    void CreateVkSemaphore(VkSemaphore* semaphore,
+        const RsVulkanContext& vkContext, NativeBufferUtils::NativeSurfaceInfo& nativeSurface);
 #else // ENABLE_NATIVEBUFFER
     vulkan::VulkanWindow* mVulkanWindow = nullptr;
-#endif  // ENABLE_NATIVEBUFFER
+#endif // ENABLE_NATIVEBUFFER
 };
 
 } // namespace Rosen
-- 
2.25.1

