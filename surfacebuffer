diff --git a/rosen/modules/2d_graphics/BUILD.gn b/rosen/modules/2d_graphics/BUILD.gn
index 9fad01736..7f238bc78 100755
--- a/rosen/modules/2d_graphics/BUILD.gn
+++ b/rosen/modules/2d_graphics/BUILD.gn
@@ -60,7 +60,15 @@ template("graphics2d_source_set") {
     if (use_texgine) {
       defines += [ "USE_TEXGINE" ]
     }
+    defines += gpu_defines
+    if (rs_enable_gpu) {
+      defines += [
+        "GL_GLEXT_PROTOTYPES",
+        "EGL_EGLEXT_PROTOTYPES",
+      ]
+    }
 
+    public_deps = []
     if (is_arkui_x) {
       defines += [ "CROSS_PLATFORM" ]
     }
@@ -197,6 +205,7 @@ template("graphics2d_source_set") {
       "//third_party/skia/src/core",
       "//third_party/skia/src/ports",
       "$rosen_root/modules/texgine/texgine_drawing/src",
+      "$graphic_2d_root/interfaces/inner_api/surface",
     ]
 
     configs = [ "//third_party/jsoncpp:jsoncpp_public_config" ]
@@ -238,8 +247,14 @@ template("graphics2d_source_set") {
       ]
     }
 
+    public_deps += [
+      "$graphic_2d_root:libgl",
+      "$graphic_2d_root/frameworks/surface:surface",
+    ]
+
     if (platform == "ohos" || platform == "ohos_ng") {
       external_deps = [
+        "c_utils:utils",
         "hilog:libhilog",
         "image_framework:image_native",
       ]
diff --git a/rosen/modules/2d_graphics/include/recording/cmd_list.h b/rosen/modules/2d_graphics/include/recording/cmd_list.h
index 3b8b8fff1..2c184fb4b 100644
--- a/rosen/modules/2d_graphics/include/recording/cmd_list.h
+++ b/rosen/modules/2d_graphics/include/recording/cmd_list.h
@@ -24,6 +24,9 @@
 #include "recording/mem_allocator.h"
 #include "recording/adaptive_image_helper.h"
 #include "utils/drawing_macros.h"
+#ifdef ROSEN_OHOS
+#include "surface_buffer.h"
+#endif
 
 namespace OHOS {
 namespace Media {
@@ -214,6 +217,28 @@ public:
     CmdList& operator=(CmdList&&) = delete;
     CmdList& operator=(const CmdList&) = delete;
 
+#ifdef ROSEN_OHOS
+    /*
+     * @brief  return surfaceBuffer index, negative is error.
+     */
+    uint32_t AddSurfaceBuffer(const sptr<SurfaceBuffer>& surfaceBuffer);
+
+    /*
+     * @brief  get surfaceBuffer by index.
+     */
+    sptr<SurfaceBuffer> GetSurfaceBuffer(uint32_t id);
+
+    /*
+     * @brief  return surfaceBuffer size, 0 is no surfaceBuffer.
+     */
+    uint32_t GetAllSurfaceBuffer(std::vector<sptr<SurfaceBuffer>>& objectList);
+
+    /*
+     * @brief  return real setup surfaceBuffer size.
+     */
+    uint32_t SetupSurfaceBuffer(const std::vector<sptr<SurfaceBuffer>>& objectList);
+#endif
+
 protected:
     MemAllocator opAllocator_;
     MemAllocator imageAllocator_;
@@ -227,6 +252,10 @@ protected:
 #endif
     std::vector<std::shared_ptr<ExtendImageBaseOj>> imageBaseOjVec_;
     std::mutex imageBaseOjMutex_;
+#ifdef ROSEN_OHOS
+    std::vector<sptr<SurfaceBuffer>> surfaceBufferVec_;
+    std::mutex surfaceBufferMutex_;
+#endif
 };
 } // namespace Drawing
 } // namespace Rosen
diff --git a/rosen/modules/2d_graphics/include/recording/cmd_list_helper.h b/rosen/modules/2d_graphics/include/recording/cmd_list_helper.h
index b649f075f..890f56622 100644
--- a/rosen/modules/2d_graphics/include/recording/cmd_list_helper.h
+++ b/rosen/modules/2d_graphics/include/recording/cmd_list_helper.h
@@ -223,6 +223,11 @@ public:
 
     static std::vector<std::shared_ptr<DrawOpItem>> GetDrawOpItemsFromHandle(
         const CmdList& cmdList, const CmdListHandle& handle);
+#ifdef ROSEN_OHOS
+    static uint32_t AddSurfaceBufferToCmdList(CmdList& cmdList, const sptr<SurfaceBuffer>& imageFilter);
+    static sptr<SurfaceBuffer> GetSurfaceBufferFromCmdList(
+        const CmdList& cmdList, uint32_t imageFilterHandle);
+#endif
 };
 } // namespace Drawing
 } // namespace Rosen
diff --git a/rosen/modules/2d_graphics/include/recording/draw_cmd.h b/rosen/modules/2d_graphics/include/recording/draw_cmd.h
index e917a65ee..15362a1f1 100644
--- a/rosen/modules/2d_graphics/include/recording/draw_cmd.h
+++ b/rosen/modules/2d_graphics/include/recording/draw_cmd.h
@@ -25,6 +25,22 @@
 #include "recording/cmd_list.h"
 #include "recording/recording_canvas.h"
 
+#ifdef ROSEN_OHOS
+#if defined(RS_ENABLE_GL) || defined(RS_ENABLE_VK)
+#include "external_window.h"
+#include "window.h"
+#endif
+#ifdef RS_ENABLE_GL
+#include <GLES/gl.h>
+#include "EGL/egl.h"
+#include "EGL/eglext.h"
+#include "GLES2/gl2.h"
+#include "GLES2/gl2ext.h"
+#include "include/gpu/gl/GrGLTypes.h"
+#include "include/gpu/GrBackendSurface.h"
+#endif
+#endif
+
 namespace OHOS {
 namespace Rosen {
 namespace Drawing {
@@ -148,6 +164,7 @@ public:
         EDGEAAQUAD_OPITEM,
         VERTICES_OPITEM,
         IMAGE_SNAPSHOT_OPITEM,
+        SURFACEBUFFER_OPITEM,
     };
 
     virtual void Playback(Canvas* canvas, const Rect* rect) = 0;
@@ -1215,6 +1232,39 @@ private:
     SamplingOptions sampling_;
     std::shared_ptr<ExtendImageBaseOj> objectHandle_;
 };
+#ifdef ROSEN_OHOS
+class DrawSurfaceBufferOpItem : public DrawOpItem {
+public:
+    struct ConstructorHandle : public OpItem {
+        ConstructorHandle(uint32_t surfaceBufferId, int offSetX, int offSetY, int width, int height)
+            : OpItem(DrawOpItem::SURFACEBUFFER_OPITEM), surfaceBufferId(surfaceBufferId),
+            surfaceBufferInfo(nullptr, offSetX, offSetY, width, height) {}
+        ~ConstructorHandle() override = default;
+        uint32_t surfaceBufferId;
+        DrawingSurfaceBufferInfo surfaceBufferInfo;
+    };
+
+    DrawSurfaceBufferOpItem(const CmdList& cmdList, ConstructorHandle* handle);
+    ~DrawSurfaceBufferOpItem() = default;
+
+    static std::shared_ptr<DrawOpItem> Unmarshalling(const CmdList& cmdList, void* handle);
+    void Playback(Canvas* canvas, const Rect* rect) override;
+
+private:
+    DrawingSurfaceBufferInfo surfaceBufferInfo_;
+    void Clear();
+    void Draw(Canvas* canvas);
+
+#if defined(RS_ENABLE_GL) || defined(RS_ENABLE_VK)
+    OHNativeWindowBuffer* nativeWindowBuffer_ = nullptr;
+#endif
+#ifdef RS_ENABLE_GL
+    EGLImageKHR eglImage_ = EGL_NO_IMAGE_KHR;
+    GLuint texId_ = 0;
+#endif
+};
+#endif
+
 } // namespace Drawing
 } // namespace Rosen
 } // namespace OHOS
diff --git a/rosen/modules/2d_graphics/include/recording/recording_canvas.h b/rosen/modules/2d_graphics/include/recording/recording_canvas.h
index a83fd9fbf..a227d53ea 100644
--- a/rosen/modules/2d_graphics/include/recording/recording_canvas.h
+++ b/rosen/modules/2d_graphics/include/recording/recording_canvas.h
@@ -21,9 +21,26 @@
 #include "draw/canvas.h"
 #include "recording/adaptive_image_helper.h"
 #include "recording/draw_cmd_list.h"
+#ifdef ROSEN_OHOS
+#include "surface_buffer.h"
+#endif
 
 namespace OHOS {
 namespace Rosen {
+#ifdef ROSEN_OHOS
+struct DrawingSurfaceBufferInfo {
+    DrawingSurfaceBufferInfo() = default;
+    DrawingSurfaceBufferInfo(
+        const sptr<SurfaceBuffer>& surfaceBuffer, int offSetX, int offSetY, int width, int height)
+        : surfaceBuffer_(surfaceBuffer), offSetX_(offSetX), offSetY_(offSetY), width_(width), height_(height)
+    {}
+    sptr<SurfaceBuffer> surfaceBuffer_ = nullptr;
+    int offSetX_ = 0;
+    int offSetY_ = 0;
+    int width_ = 0;
+    int height_ = 0;
+};
+#endif
 namespace Drawing {
 /*
  * @brief  RecordingCanvas is an empty canvas, which does not act on any surface,
@@ -126,6 +143,9 @@ public:
 
     void SetIsCustomTextType(bool isCustomTextType);
     bool IsCustomTextType() const;
+#ifdef ROSEN_OHOS
+    void DrawSurfaceBuffer(const DrawingSurfaceBufferInfo& surfaceBufferInfo);
+#endif
 private:
     enum SaveOpState {
         LazySaveOp,
diff --git a/rosen/modules/2d_graphics/src/drawing/recording/cmd_list.cpp b/rosen/modules/2d_graphics/src/drawing/recording/cmd_list.cpp
index 2d99e8269..62503ff24 100644
--- a/rosen/modules/2d_graphics/src/drawing/recording/cmd_list.cpp
+++ b/rosen/modules/2d_graphics/src/drawing/recording/cmd_list.cpp
@@ -37,6 +37,9 @@ CmdList::~CmdList()
 #ifdef SUPPORT_OHOS_PIXMAP
     pixelMapVec_.clear();
 #endif
+#ifdef ROSEN_OHOS
+    surfaceBufferVec_.clear();
+#endif
 }
 
 uint32_t CmdList::AddCmdListData(const CmdListData& data)
@@ -235,6 +238,42 @@ void CmdList::CopyObjectTo(CmdList& other) const
 #endif
     other.imageBaseOjVec_ = imageBaseOjVec_;
 }
+
+#ifdef ROSEN_OHOS
+uint32_t CmdList::AddSurfaceBuffer(const sptr<SurfaceBuffer>& surfaceBuffer)
+{
+    std::lock_guard<std::mutex> lock(surfaceBufferMutex_);
+    surfaceBufferVec_.emplace_back(surfaceBuffer);
+    return static_cast<uint32_t>(surfaceBufferVec_.size()) - 1;
+}
+
+sptr<SurfaceBuffer> CmdList::GetSurfaceBuffer(uint32_t id)
+{
+    std::lock_guard<std::mutex> lock(surfaceBufferMutex_);
+    if (id >= surfaceBufferVec_.size()) {
+        return nullptr;
+    }
+    return surfaceBufferVec_[id];
+}
+
+uint32_t CmdList::GetAllSurfaceBuffer(std::vector<sptr<SurfaceBuffer>>& objectList)
+{
+    std::lock_guard<std::mutex> lock(surfaceBufferMutex_);
+    for (const auto &object : surfaceBufferVec_) {
+        objectList.emplace_back(object);
+    }
+    return objectList.size();
+}
+
+uint32_t CmdList::SetupSurfaceBuffer(const std::vector<sptr<SurfaceBuffer>>& objectList)
+{
+    std::lock_guard<std::mutex> lock(surfaceBufferMutex_);
+    for (const auto &object : objectList) {
+        surfaceBufferVec_.emplace_back(object);
+    }
+    return surfaceBufferVec_.size();
+}
+#endif
 } // namespace Drawing
 } // namespace Rosen
 } // namespace OHOS
diff --git a/rosen/modules/2d_graphics/src/drawing/recording/cmd_list_helper.cpp b/rosen/modules/2d_graphics/src/drawing/recording/cmd_list_helper.cpp
index 3f8faa661..397ae951f 100644
--- a/rosen/modules/2d_graphics/src/drawing/recording/cmd_list_helper.cpp
+++ b/rosen/modules/2d_graphics/src/drawing/recording/cmd_list_helper.cpp
@@ -692,7 +692,18 @@ std::vector<std::shared_ptr<DrawOpItem>> CmdListHelper::GetDrawOpItemsFromHandle
 
     return drawCmdList->UnmarshallingCmdList();
 }
+#ifdef ROSEN_OHOS
+uint32_t CmdListHelper::AddSurfaceBufferToCmdList(CmdList& cmdList, const sptr<SurfaceBuffer>& surfaceBuffer)
+{
+    return cmdList.AddSurfaceBuffer(surfaceBuffer);
+}
 
+sptr<SurfaceBuffer> CmdListHelper::GetSurfaceBufferFromCmdList(
+    const CmdList& cmdList, uint32_t surfaceBufferHandle)
+{
+    return (const_cast<CmdList&>(cmdList)).GetSurfaceBuffer(surfaceBufferHandle);
+}
+#endif
 } // namespace Drawing
 } // namespace Rosen
 } // namespace OHOS
diff --git a/rosen/modules/2d_graphics/src/drawing/recording/draw_cmd.cpp b/rosen/modules/2d_graphics/src/drawing/recording/draw_cmd.cpp
index c19badf63..477447c40 100644
--- a/rosen/modules/2d_graphics/src/drawing/recording/draw_cmd.cpp
+++ b/rosen/modules/2d_graphics/src/drawing/recording/draw_cmd.cpp
@@ -224,6 +224,9 @@ std::unordered_map<uint32_t, UnmarshallingPlayer::UnmarshallingFunc> Unmarshalli
     { DrawOpItem::PATCH_OPITEM,             DrawPatchOpItem::Unmarshalling },
     { DrawOpItem::EDGEAAQUAD_OPITEM, DrawEdgeAAQuadOpItem::Unmarshalling },
     { DrawOpItem::VERTICES_OPITEM,          DrawVerticesOpItem::Unmarshalling },
+#ifdef ROSEN_OHOS
+    { DrawOpItem::SURFACEBUFFER_OPITEM,          DrawSurfaceBufferOpItem::Unmarshalling },
+#endif
 };
 
 UnmarshallingPlayer::UnmarshallingPlayer(const CmdList& cmdList) : cmdList_(cmdList) {}
@@ -1401,6 +1404,126 @@ void ImageSnapshotOpItem::Playback(Canvas* canvas, const Rect* rect)
     }
     canvas->DrawImageRect(*image_, src_, dst_, sampling_, constraint_);
 }
+#ifdef ROSEN_OHOS
+DrawSurfaceBufferOpItem::DrawSurfaceBufferOpItem(const CmdList& cmdList,
+    DrawSurfaceBufferOpItem::ConstructorHandle* handle)
+    : DrawOpItem(SURFACEBUFFER_OPITEM), surfaceBufferInfo_(nullptr, handle->surfaceBufferInfo.offSetX_,
+    handle->surfaceBufferInfo.offSetY_, handle->surfaceBufferInfo.width_, handle->surfaceBufferInfo.height_)
+{
+    surfaceBufferInfo_.surfaceBuffer_ = CmdListHelper::GetSurfaceBufferFromCmdList(cmdList, handle->surfaceBufferId);
+}
+
+std::shared_ptr<DrawOpItem> DrawSurfaceBufferOpItem::Unmarshalling(const CmdList& cmdList, void* handle)
+{
+    return std::make_shared<DrawSurfaceBufferOpItem>(cmdList,
+        static_cast<DrawSurfaceBufferOpItem::ConstructorHandle*>(handle));
+}
+
+void DrawSurfaceBufferOpItem::Playback(Canvas* canvas, const Rect* rect)
+{
+    Clear();
+#if defined(RS_ENABLE_GL) || defined(RS_ENABLE_VK)
+    if (surfaceBufferInfo_.surfaceBuffer_ == nullptr) {
+        LOGE("SurfaceBufferOpItem::Draw surfaceBuffer_ is nullptr");
+        return;
+    }
+    nativeWindowBuffer_ = CreateNativeWindowBufferFromSurfaceBuffer(&(surfaceBufferInfo_.surfaceBuffer_));
+    if (!nativeWindowBuffer_) {
+        LOGE("create nativeWindowBuffer_ fail.");
+        return;
+    }
+#endif
+    Draw(canvas);
+}
+
+void DrawSurfaceBufferOpItem::Clear()
+{
+#ifdef RS_ENABLE_GL
+    if (texId_ != 0U) {
+        glDeleteTextures(1, &texId_);
+    }
+    if (eglImage_ != EGL_NO_IMAGE_KHR) {
+        auto disp = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+        eglDestroyImageKHR(disp, eglImage_);
+    }
+#endif
+#if defined(RS_ENABLE_GL) || defined(RS_ENABLE_VK)
+    if (nativeWindowBuffer_ != nullptr) {
+        DestroyNativeWindowBuffer(nativeWindowBuffer_);
+    }
+#endif
+}
+
+void DrawSurfaceBufferOpItem::Draw(Canvas* canvas)
+{
+#ifdef RS_ENABLE_GL
+    EGLint attrs[] = {
+        EGL_IMAGE_PRESERVED,
+        EGL_TRUE,
+        EGL_NONE,
+    };
+
+    auto disp = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    eglImage_ = eglCreateImageKHR(disp, EGL_NO_CONTEXT, EGL_NATIVE_BUFFER_OHOS, nativeWindowBuffer_, attrs);
+    if (eglImage_ == EGL_NO_IMAGE_KHR) {
+        DestroyNativeWindowBuffer(nativeWindowBuffer_);
+        LOGE("%{public}s create egl image fail %{public}d", __func__, eglGetError());
+        return;
+    }
+
+    // save
+    GLuint originTexture;
+    glGetIntegerv(GL_TEXTURE_BINDING_2D, reinterpret_cast<GLint *>(&originTexture));
+    GLint minFilter;
+    glGetTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, &minFilter);
+    GLint magFilter;
+    glGetTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, &magFilter);
+    GLint wrapS;
+    glGetTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, &wrapS);
+    GLint wrapT;
+    glGetTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, &wrapT);
+
+    // Create texture object
+    texId_ = 0;
+    glGenTextures(1, &texId_);
+    glBindTexture(GL_TEXTURE_2D, texId_);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+    glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, static_cast<GLeglImageOES>(eglImage_));
+
+    // restore
+    glBindTexture(GL_TEXTURE_2D, originTexture);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapS);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapT);
+
+    GrGLTextureInfo textureInfo = { GL_TEXTURE_2D, texId_, GL_RGBA8_OES };
+
+    GrBackendTexture backendTexture(
+        surfaceBufferInfo_.width_, surfaceBufferInfo_.height_, GrMipMapped::kNo, textureInfo);
+
+    Drawing::TextureInfo externalTextureInfo;
+                externalTextureInfo.SetWidth(surfaceBufferInfo_.width_);
+                externalTextureInfo.SetHeight(surfaceBufferInfo_.height_);
+                externalTextureInfo.SetIsMipMapped(false);
+                externalTextureInfo.SetTarget(GL_TEXTURE_2D);
+                externalTextureInfo.SetID(texId_);
+                externalTextureInfo.SetFormat(GL_RGBA8_OES);
+    Drawing::BitmapFormat bitmapFormat = { Drawing::ColorType::COLORTYPE_RGBA_8888,
+        Drawing::AlphaType::ALPHATYPE_PREMUL };
+    auto newImage = std::make_shared<Drawing::Image>();
+    if (!newImage->BuildFromTexture(*canvas->GetGPUContext(), externalTextureInfo,
+        Drawing::TextureOrigin::TOP_LEFT, bitmapFormat, nullptr)) {
+        LOGD("RSFilterCacheManager::Render: cacheCanvas is null");
+        return;
+    }
+    canvas->DrawImage(*newImage, surfaceBufferInfo_.offSetX_, surfaceBufferInfo_.offSetY_, Drawing::SamplingOptions());
+#endif // RS_ENABLE_GL
+}
+#endif
 } // namespace Drawing
 } // namespace Rosen
 } // namespace OHOS
diff --git a/rosen/modules/2d_graphics/src/drawing/recording/draw_cmd_list.cpp b/rosen/modules/2d_graphics/src/drawing/recording/draw_cmd_list.cpp
index 7878fe0cf..a72e542c7 100644
--- a/rosen/modules/2d_graphics/src/drawing/recording/draw_cmd_list.cpp
+++ b/rosen/modules/2d_graphics/src/drawing/recording/draw_cmd_list.cpp
@@ -246,7 +246,7 @@ void DrawCmdList::Playback(Canvas& canvas, const Rect* rect)
         return;
     }
     uint32_t offset = 2 * sizeof(int32_t); // 2 is width and height.Offset of first OpItem is behind the w and h
-    if (opAllocator_.GetSize() <= offset && unmarshalledOpItems_.size() == 0) {
+    if (width_ <= 0 || height_ <= 0 || (opAllocator_.GetSize() <= offset && unmarshalledOpItems_.size() == 0)) {
         return;
     }
 
diff --git a/rosen/modules/2d_graphics/src/drawing/recording/recording_canvas.cpp b/rosen/modules/2d_graphics/src/drawing/recording/recording_canvas.cpp
index 0f1e38669..8dca70dbe 100755
--- a/rosen/modules/2d_graphics/src/drawing/recording/recording_canvas.cpp
+++ b/rosen/modules/2d_graphics/src/drawing/recording/recording_canvas.cpp
@@ -298,6 +298,15 @@ void RecordingCanvas::DrawTextBlob(const TextBlob* blob, const scalar x, const s
     auto textBlobHandle = CmdListHelper::AddTextBlobToCmdList(*cmdList_, blob);
     cmdList_->AddOp<DrawTextBlobOpItem::ConstructorHandle>(textBlobHandle, x, y);
 }
+#ifdef ROSEN_OHOS
+void RecordingCanvas::DrawSurfaceBuffer(const DrawingSurfaceBufferInfo& surfaceBufferInfo)
+{
+    cmdList_->AddOp<DrawSurfaceBufferOpItem::ConstructorHandle>(
+        CmdListHelper::AddSurfaceBufferToCmdList(*cmdList_, surfaceBufferInfo.surfaceBuffer_),
+        surfaceBufferInfo.offSetX_, surfaceBufferInfo.offSetY_,
+        surfaceBufferInfo.width_, surfaceBufferInfo.height_);
+}
+#endif
 
 void RecordingCanvas::ClipRect(const Rect& rect, ClipOp op, bool doAntiAlias)
 {
